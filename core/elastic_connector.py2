from elasticsearch import Elasticsearch
from config.settings import ELASTIC_HOST, ELASTIC_USER, ELASTIC_PASSWORD, ELASTIC_INDEX_PATTERN
import logging
from datetime import datetime, timedelta

logger = logging.getLogger(__name__)


class ElasticConnector:
    def __init__(self):
        self.host = ELASTIC_HOST
        self.index_pattern = ELASTIC_INDEX_PATTERN

        # Setup connection
        if ELASTIC_USER and ELASTIC_PASSWORD:
            self.es = Elasticsearch(
                [self.host],
                basic_auth=(ELASTIC_USER, ELASTIC_PASSWORD),
                verify_certs=False
            )
        else:
            self.es = Elasticsearch([self.host], verify_certs=False)

    def test_connection(self):
        """Test connection to Elasticsearch"""
        try:
            return self.es.ping()
        except Exception as e:
            logger.error(f"Failed to connect to Elasticsearch: {e}")
            return False

    def get_recent_logs(self, minutes=60, size=100, index_pattern=None):
        """
        Get recent logs from Elasticsearch (GENERAL - all sources)
        
        Args:
            minutes: Waktu dalam menit ke belakang
            size: Jumlah log yang diambil
            index_pattern: Pattern index khusus (opsional)
        
        Returns:
            List of log sources
        """
        try:
            # Gunakan index pattern dari parameter atau default
            target_index = index_pattern or self.index_pattern
            
            # Query general tanpa filter dataset spesifik
            query = {
                "query": {
                    "range": {
                        "@timestamp": {
                            "gte": f"now-{minutes}m",
                            "lt": "now"
                        }
                    }
                },
                "sort": [{"@timestamp": "desc"}],
                "size": size
            }

            result = self.es.search(index=target_index, body=query)
            return [hit['_source'] for hit in result['hits']['hits']]

        except Exception as e:
            logger.error(f"Error getting logs: {e}")
            return []

    def count_failed_logins(self, minutes=5):
        """Count failed login attempts from all sources (HTTP 401/403, authentication failures)"""
        try:
            query = {
                "query": {
                    "bool": {
                        "must": [
                            {"range": {"@timestamp": {"gte": f"now-{minutes}m"}}}
                        ],
                        "should": [
                            {"match": {"http.response.status_code": 401}},
                            {"match": {"http.response.status_code": 403}},
                            {"match": {"event.type": "authentication_failure"}},
                            {"match": {"event.outcome": "failure"}},
                            {"match": {"event.category": "authentication"}},
                            {"match": {"message": "failed login"}},
                            {"match": {"message": "authentication failed"}},
                            {"match": {"message": "invalid password"}},
                            {"match": {"message": "access denied"}},
                            {"match": {"message": "login incorrect"}}
                        ],
                        "minimum_should_match": 1
                    }
                }
            }

            result = self.es.count(index=self.index_pattern, body=query)
            return result['count']

        except Exception as e:
            logger.error(f"Error counting failed logins: {e}")
            return 0

    def get_top_attackers(self, minutes=60, size=10):
        """
        Get top attacking IPs from all sources
        
        Mencari IP dengan aktivitas mencurigakan terbanyak
        (error, authentication failure, status code 4xx/5xx)
        """
        try:
            # Cari IP dengan status code error atau pattern mencurigakan
            query = {
                "query": {
                    "bool": {
                        "must": [
                            {"range": {"@timestamp": {"gte": f"now-{minutes}m"}}}
                        ],
                        "should": [
                            {"range": {"http.response.status_code": {"gte": 400}}},
                            {"match": {"event.type": "error"}},
                            {"match": {"event.category": "authentication"}},
                            {"match": {"event.outcome": "failure"}},
                            {"match": {"log.level": "error"}},
                            {"match": {"log.level": "critical"}},
                            {"match": {"message": "error"}},
                            {"match": {"message": "failed"}},
                            {"match": {"message": "denied"}},
                            {"match": {"message": "rejected"}},
                            {"match": {"message": "invalid"}},
                            {"match": {"message": "unauthorized"}},
                            {"match": {"message": "forbidden"}}
                        ],
                        "minimum_should_match": 1
                    }
                },
                "aggs": {
                    "top_ips": {
                        "terms": {
                            "field": "source.ip.keyword",
                            "size": size
                        }
                    }
                },
                "size": 0
            }

            result = self.es.search(index=self.index_pattern, body=query)
            
            # Handle jika aggregations tidak ada
            if 'aggregations' not in result:
                return []
                
            buckets = result['aggregations']['top_ips']['buckets']

            return [{"ip": bucket['key'], "count": bucket['doc_count']}
                    for bucket in buckets]

        except Exception as e:
            logger.error(f"Error getting top attackers: {e}")
            return []

    def get_attack_timeline(self, minutes=60):
        """
        Get timeline of suspicious activities from all sources
        """
        try:
            # Cari semua event mencurigakan (error, authentication failure, dll)
            query = {
                "query": {
                    "bool": {
                        "must": [
                            {"range": {"@timestamp": {"gte": f"now-{minutes}m"}}}
                        ],
                        "should": [
                            {"range": {"http.response.status_code": {"gte": 400}}},
                            {"match": {"event.type": "error"}},
                            {"match": {"event.category": "authentication"}},
                            {"match": {"event.outcome": "failure"}},
                            {"match": {"log.level": "error"}},
                            {"match": {"log.level": "critical"}},
                            {"match": {"log.level": "warning"}},
                            {"match": {"message": "error"}},
                            {"match": {"message": "failed"}},
                            {"match": {"message": "denied"}},
                            {"match": {"message": "rejected"}},
                            {"match": {"message": "invalid"}},
                            {"match": {"message": "unauthorized"}},
                            {"match": {"message": "forbidden"}},
                            {"match": {"message": "attack"}},
                            {"match": {"message": "exploit"}},
                            {"match": {"message": "malicious"}}
                        ],
                        "minimum_should_match": 1
                    }
                },
                "aggs": {
                    "attacks_over_time": {
                        "date_histogram": {
                            "field": "@timestamp",
                            "fixed_interval": "5m"
                        }
                    }
                },
                "size": 0
            }

            result = self.es.search(index=self.index_pattern, body=query)
            
            if 'aggregations' not in result:
                return []
                
            return result['aggregations']['attacks_over_time']['buckets']

        except Exception as e:
            logger.error(f"Error getting attack timeline: {e}")
            return []

    def get_error_logs(self, minutes=60, size=50):
        """
        Get error logs from all sources
        """
        try:
            query = {
                "query": {
                    "bool": {
                        "must": [
                            {"range": {"@timestamp": {"gte": f"now-{minutes}m"}}}
                        ],
                        "should": [
                            {"match": {"event.type": "error"}},
                            {"match": {"log.level": "error"}},
                            {"match": {"log.level": "critical"}},
                            {"match": {"log.level": "alert"}},
                            {"match": {"log.level": "emergency"}},
                            {"match": {"message": "error"}},
                            {"match": {"message": "exception"}},
                            {"match": {"message": "failed"}},
                            {"match": {"message": "crash"}},
                            {"match": {"message": "timeout"}},
                            {"match": {"message": "unable"}},
                            {"match": {"message": "cannot"}},
                            {"match": {"message": "not found"}}
                        ],
                        "minimum_should_match": 1
                    }
                },
                "sort": [{"@timestamp": "desc"}],
                "size": size
            }

            result = self.es.search(index=self.index_pattern, body=query)
            return [hit['_source'] for hit in result['hits']['hits']]

        except Exception as e:
            logger.error(f"Error getting error logs: {e}")
            return []

    def get_suspicious_requests(self, minutes=60):
        """
        Get requests with suspicious patterns from all sources
        (SQL injection, XSS, path traversal, command injection, etc)
        """
        try:
            query = {
                "query": {
                    "bool": {
                        "must": [
                            {"range": {"@timestamp": {"gte": f"now-{minutes}m"}}}
                        ],
                        "should": [
                            # SQL Injection patterns
                            {"wildcard": {"url.original": {"value": "*union*select*"}}},
                            {"wildcard": {"url.original": {"value": "*select*from*"}}},
                            {"wildcard": {"url.original": {"value": "*1=1*"}}},
                            {"wildcard": {"url.original": {"value": "*--*"}}},
                            {"wildcard": {"url.original": {"value": "*DROP*TABLE*"}}},
                            {"wildcard": {"url.original": {"value": "*information_schema*"}}},
                            {"wildcard": {"url.original": {"value": "*0x*"}}},
                            {"wildcard": {"url.original": {"value": "*;*"}}},
                            
                            # XSS patterns
                            {"wildcard": {"url.original": {"value": "*<script>*"}}},
                            {"wildcard": {"url.original": {"value": "*javascript:*"}}},
                            {"wildcard": {"url.original": {"value": "*onerror=*"}}},
                            {"wildcard": {"url.original": {"value": "*onload=*"}}},
                            {"wildcard": {"url.original": {"value": "*alert(*"}}},
                            {"wildcard": {"url.original": {"value": "*prompt(*"}}},
                            {"wildcard": {"url.original": {"value": "*confirm(*"}}},
                            
                            # Path Traversal
                            {"wildcard": {"url.original": {"value": "*../*"}}},
                            {"wildcard": {"url.original": {"value": "*..\\*"}}},
                            {"wildcard": {"url.original": {"value": "*%2e%2e%2f*"}}},
                            {"wildcard": {"url.original": {"value": "*%2e%2e%5c*"}}},
                            {"wildcard": {"url.original": {"value": "*etc/passwd*"}}},
                            {"wildcard": {"url.original": {"value": "*windows\\system32*"}}},
                            
                            # Command Injection
                            {"wildcard": {"url.original": {"value": "*;ls*"}}},
                            {"wildcard": {"url.original": {"value": "*;cat*"}}},
                            {"wildcard": {"url.original": {"value": "*;wget*"}}},
                            {"wildcard": {"url.original": {"value": "*;curl*"}}},
                            {"wildcard": {"url.original": {"value": "*|sh*"}}},
                            {"wildcard": {"url.original": {"value": "*|bash*"}}},
                            {"wildcard": {"url.original": {"value": "*`*`*"}}},
                            
                            # File inclusion
                            {"wildcard": {"url.original": {"value": "*include*"}}},
                            {"wildcard": {"url.original": {"value": "*require*"}}},
                            {"wildcard": {"url.original": {"value": "*file=*"}}},
                            {"wildcard": {"url.original": {"value": "*document=*"}}}
                        ],
                        "minimum_should_match": 1
                    }
                },
                "sort": [{"@timestamp": "desc"}],
                "size": 100
            }

            result = self.es.search(index=self.index_pattern, body=query)
            return [hit['_source'] for hit in result['hits']['hits']]

        except Exception as e:
            logger.error(f"Error getting suspicious requests: {e}")
            return []

    def get_log_sources(self, minutes=60):
        """
        Mendapatkan daftar sumber log yang aktif
        
        Returns:
            Dictionary dengan statistik per sumber
        """
        try:
            query = {
                "query": {
                    "range": {
                        "@timestamp": {"gte": f"now-{minutes}m"}
                    }
                },
                "aggs": {
                    "by_event_dataset": {
                        "terms": {
                            "field": "event.dataset.keyword",
                            "size": 20
                        }
                    },
                    "by_service_type": {
                        "terms": {
                            "field": "service.type.keyword",
                            "size": 20
                        }
                    },
                    "by_agent_type": {
                        "terms": {
                            "field": "agent.type.keyword",
                            "size": 10
                        }
                    },
                    "by_host_os": {
                        "terms": {
                            "field": "host.os.family.keyword",
                            "size": 10
                        }
                    }
                },
                "size": 0
            }

            result = self.es.search(index=self.index_pattern, body=query)
            
            sources = {}
            
            if 'aggregations' in result:
                # Parse event.dataset
                if 'by_event_dataset' in result['aggregations']:
                    for bucket in result['aggregations']['by_event_dataset']['buckets']:
                        sources[f"dataset:{bucket['key']}"] = bucket['doc_count']
                
                # Parse service.type
                if 'by_service_type' in result['aggregations']:
                    for bucket in result['aggregations']['by_service_type']['buckets']:
                        sources[f"service:{bucket['key']}"] = bucket['doc_count']
                
                # Parse agent.type
                if 'by_agent_type' in result['aggregations']:
                    for bucket in result['aggregations']['by_agent_type']['buckets']:
                        sources[f"agent:{bucket['key']}"] = bucket['doc_count']
            
            return sources

        except Exception as e:
            logger.error(f"Error getting log sources: {e}")
            return {}

    def search_custom(self, query_body, index_pattern=None, size=100):
        """
        Custom search dengan query bebas
        
        Args:
            query_body: Dictionary query Elasticsearch
            index_pattern: Pattern index (opsional)
            size: Jumlah hasil
        
        Returns:
            Raw response dari Elasticsearch
        """
        try:
            target_index = index_pattern or self.index_pattern
            result = self.es.search(
                index=target_index,
                body=query_body,
                size=size
            )
            return result
        except Exception as e:
            logger.error(f"Error in custom search: {e}")
            return None

    def get_index_stats(self):
        """
        Mendapatkan statistik tentang index yang tersedia
        
        Returns:
            Dictionary dengan informasi index
        """
        try:
            # Dapatkan semua index yang cocok dengan pattern
            indices = self.es.cat.indices(index=self.index_pattern, format='json', h='index,docs.count,store.size')
            
            stats = {
                'total_indices': len(indices),
                'indices': indices,
                'total_docs': sum(int(idx.get('docs.count', 0)) for idx in indices if idx.get('docs.count') != 'null'),
                'total_size': sum(int(idx.get('store.size', 0)) for idx in indices if idx.get('store.size') != 'null')
            }
            
            return stats
        except Exception as e:
            logger.error(f"Error getting index stats: {e}")
            return {}
